{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EPITECH Documentation Table of Content I. ABOUT EPITECH Epitech PEDAGOGY Links & Documents II. INSTALLATIONS & CONFIGURATIONS Windows + Linux Distro EPITECH DUMP III. TOOLS CHEATSHEET Blih Git Emacs Makefile Coding style Csfml Library Ncurses Library IV. C PROGRAMMING Simples functions Your library Unit Test V. ABOUT US EPITOOLS Contribution License First solve the problem. Then, write the code. \u2013 John Johnson","title":"Welcome to EPITECH Documentation"},{"location":"#welcome-to-epitech-documentation","text":"","title":"Welcome to EPITECH Documentation"},{"location":"#table-of-content","text":"I. ABOUT EPITECH Epitech PEDAGOGY Links & Documents II. INSTALLATIONS & CONFIGURATIONS Windows + Linux Distro EPITECH DUMP III. TOOLS CHEATSHEET Blih Git Emacs Makefile Coding style Csfml Library Ncurses Library IV. C PROGRAMMING Simples functions Your library Unit Test V. ABOUT US EPITOOLS Contribution License First solve the problem. Then, write the code. \u2013 John Johnson","title":"Table of Content"},{"location":"about_epitech/epitech/","text":"Description Epitech is a really different school from the ones we are used to seeing. l takes place over 5 years and trains professional and ready-to-use IT experts. It offers dense and varied technical content, including a diversity of programming projects, and covering many languages that will allow the student to approach all new technologies with serenity. \u201cAt the end of the five-year course, the Epitech student is an expert in computer science, autonomous, responsible and perfectly adaptable to the business world. As he or she is technically speaking ultra-competent, the student obviously knows how to create and combine ideas and technology, but also how to surround themselves with the best partners to direct their projects. In a world that is in permanent evolution and where innovation dictates the rules, the student also has the necessary ammunition that is essential in order to succeed.\u201d Emmanuel Carli, General Director A two-cycle program The 1st Cycle: three years for the Epitech Bachelor Degree { Fundamentals || Consolidation || Mastery } The most noticeable aspect of the first two years is without doubt the omnipresent technique, seen across numerous large-scale projects of varied complexities. In order to reach this aspired level, Epitech students are confronted with a heavy workload and demanding rigour. Over and above the purely technical aspect, this learning method provides a real individual structure for the students. It forges their personal organisation, tests their perseverance and creates a real group work culture and collective success. By relying on the solid base put in place in the 1st and 2nd years, the 3rd year at Epitech provides a quick and easy access to many computer domains (artificial intelligence, databases, security, advanced object orientation programming, network, and so on). In order to reach operational level in a company leading to the Epitech Bachelor in Information Technology, the 3rd year makes it possible to bring together the big players in the market (Microsoft, Oracle, Cisco). The bases of the economic and relations mechanisms in a business are approached so as to allow the students to gain a good understanding of the economic context (commerce, communication, marketing, finance, law, etc). The 2nd cycle, or Expertise cycle, lasts 2 years : { Internationalization || Leadership } The international dimension is essential at Epitech. The 4th year takes place entirely abroad, in one of our 90 partner universities. On the programme: discovering new cultures, observing one\u2019s own country from abroad, learning new teaching methods and expanding one\u2019s network. In a globalized world, a high-level career, especially in computer science, cannot be achieved in the absence of an international dimension. During this period, Epitech students are immersed in the heart of a new working environment and can choose the courses best suited to their career project and their centres of interest. They continue to work as a team on their Epitech Innovative Project, remotely and far from each other, as they would be led to do if they joined an international company. During this last year, the students are inspired by more than 50 seminars given by high-level speakers: academics or professionals, French or foreign\u2026 They address topics as varied as the analysis of data, quantum computing, innovation management or artificial intelligence\u2026 At the same time, students work 3 days a week in a company and do a 6-month internship at the end of the course \u2013 two real bridges to the professional world. Those whose EIP project is already completed can also choose to devote this time to starting a business. This 5th year also sees the completion of 3 years of teamwork on the main project of the Epitech curriculum: The Epitech Innovative Project. Opportunities DEVOPS : Merger of developer and system administrator DEVELOPER: He/She is responsible for programming using computer languages, such as C++ or JAVA PROJECT MANAGER: He/She translates customer requests into IT Solutions CTO: He/She is in charge of the technological innovation of the company QUALITY ASSURANCE ENGINEER: He/She ensures the quality of software development and provides recommendations IT ARCHITECT: He/She designs and develops information systems, hardware, software, networks.","title":"Epitech PEDAGOGY"},{"location":"about_epitech/epitech/#description","text":"Epitech is a really different school from the ones we are used to seeing. l takes place over 5 years and trains professional and ready-to-use IT experts. It offers dense and varied technical content, including a diversity of programming projects, and covering many languages that will allow the student to approach all new technologies with serenity. \u201cAt the end of the five-year course, the Epitech student is an expert in computer science, autonomous, responsible and perfectly adaptable to the business world. As he or she is technically speaking ultra-competent, the student obviously knows how to create and combine ideas and technology, but also how to surround themselves with the best partners to direct their projects. In a world that is in permanent evolution and where innovation dictates the rules, the student also has the necessary ammunition that is essential in order to succeed.\u201d Emmanuel Carli, General Director","title":"Description"},{"location":"about_epitech/epitech/#a-two-cycle-program","text":"","title":"A two-cycle program"},{"location":"about_epitech/epitech/#the-1st-cycle-three-years-for-the-epitech-bachelor-degree","text":"{ Fundamentals || Consolidation || Mastery } The most noticeable aspect of the first two years is without doubt the omnipresent technique, seen across numerous large-scale projects of varied complexities. In order to reach this aspired level, Epitech students are confronted with a heavy workload and demanding rigour. Over and above the purely technical aspect, this learning method provides a real individual structure for the students. It forges their personal organisation, tests their perseverance and creates a real group work culture and collective success. By relying on the solid base put in place in the 1st and 2nd years, the 3rd year at Epitech provides a quick and easy access to many computer domains (artificial intelligence, databases, security, advanced object orientation programming, network, and so on). In order to reach operational level in a company leading to the Epitech Bachelor in Information Technology, the 3rd year makes it possible to bring together the big players in the market (Microsoft, Oracle, Cisco). The bases of the economic and relations mechanisms in a business are approached so as to allow the students to gain a good understanding of the economic context (commerce, communication, marketing, finance, law, etc).","title":"The 1st Cycle: three years for the Epitech Bachelor Degree"},{"location":"about_epitech/epitech/#the-2nd-cycle-or-expertise-cycle-lasts-2-years","text":"{ Internationalization || Leadership } The international dimension is essential at Epitech. The 4th year takes place entirely abroad, in one of our 90 partner universities. On the programme: discovering new cultures, observing one\u2019s own country from abroad, learning new teaching methods and expanding one\u2019s network. In a globalized world, a high-level career, especially in computer science, cannot be achieved in the absence of an international dimension. During this period, Epitech students are immersed in the heart of a new working environment and can choose the courses best suited to their career project and their centres of interest. They continue to work as a team on their Epitech Innovative Project, remotely and far from each other, as they would be led to do if they joined an international company. During this last year, the students are inspired by more than 50 seminars given by high-level speakers: academics or professionals, French or foreign\u2026 They address topics as varied as the analysis of data, quantum computing, innovation management or artificial intelligence\u2026 At the same time, students work 3 days a week in a company and do a 6-month internship at the end of the course \u2013 two real bridges to the professional world. Those whose EIP project is already completed can also choose to devote this time to starting a business. This 5th year also sees the completion of 3 years of teamwork on the main project of the Epitech curriculum: The Epitech Innovative Project.","title":"The 2nd cycle, or Expertise cycle, lasts 2 years :"},{"location":"about_epitech/epitech/#opportunities","text":"DEVOPS : Merger of developer and system administrator DEVELOPER: He/She is responsible for programming using computer languages, such as C++ or JAVA PROJECT MANAGER: He/She translates customer requests into IT Solutions CTO: He/She is in charge of the technological innovation of the company QUALITY ASSURANCE ENGINEER: He/She ensures the quality of software development and provides recommendations IT ARCHITECT: He/She designs and develops information systems, hardware, software, networks.","title":"Opportunities"},{"location":"about_epitech/links_docs/","text":"Links Most of these links can only be accessed with your Office 365 credentials provided when registering for EPITECH. OFFICIEL WEBSITE : https://epitech.eu/ INTRA : https://intra.epitech.eu/ Nao Marvin : https://my.epitech.eu/ ENGLISH : https://www.altissia.org/ OFFICE : https://www.office.com/ GITHUB : https://education.github.com/pack VMWARE : https://www.vmware.com/products.html JETBRAINS : https://www.jetbrains.com/ LIBRARY : http://www.scholarvox.com/ TIMELINE AND MIRROR FOR YOUR PROJECTS : https://roslyn.epi.codes/ BLIH WEB : https://blih.saumon.io/ EPITECH JOB TEASER : https://epitech.jobteaser.com/fr/users/sign_in EPITECH INNOVATIVE PROJECT : https://eip.epitech.eu/#/login EPITECH HUB : http://hub.epitech.eu/#/ EPITECH ALUMNI : http://epitech-alumni.org/ International Epitech platform : https://tekfeed.epitech.eu/#/ EPITECH DOCUMENTATION : https://epitech-2022-technical-documentation.readthedocs.io/en/latest/# EPITECH PROJECT : https://github.com/epitools2024/EPITECH_PROJECTS.git EPITECH DOCUMENTATION : https://github.com/epitools2024/EPITECH-DOCUMENTATION.git EPITECH API DOCUMENTATION (Just for more fun) : Epitech API IONIS EDUCATION GROUP : IONIS EDUCATION GROUP Documents Here you will find a list of important documents which will be useful to you during your course. https://intra.epitech.eu/file/public/","title":"Links & Documents"},{"location":"about_epitech/links_docs/#links","text":"Most of these links can only be accessed with your Office 365 credentials provided when registering for EPITECH. OFFICIEL WEBSITE : https://epitech.eu/ INTRA : https://intra.epitech.eu/ Nao Marvin : https://my.epitech.eu/ ENGLISH : https://www.altissia.org/ OFFICE : https://www.office.com/ GITHUB : https://education.github.com/pack VMWARE : https://www.vmware.com/products.html JETBRAINS : https://www.jetbrains.com/ LIBRARY : http://www.scholarvox.com/ TIMELINE AND MIRROR FOR YOUR PROJECTS : https://roslyn.epi.codes/ BLIH WEB : https://blih.saumon.io/ EPITECH JOB TEASER : https://epitech.jobteaser.com/fr/users/sign_in EPITECH INNOVATIVE PROJECT : https://eip.epitech.eu/#/login EPITECH HUB : http://hub.epitech.eu/#/ EPITECH ALUMNI : http://epitech-alumni.org/ International Epitech platform : https://tekfeed.epitech.eu/#/ EPITECH DOCUMENTATION : https://epitech-2022-technical-documentation.readthedocs.io/en/latest/# EPITECH PROJECT : https://github.com/epitools2024/EPITECH_PROJECTS.git EPITECH DOCUMENTATION : https://github.com/epitools2024/EPITECH-DOCUMENTATION.git EPITECH API DOCUMENTATION (Just for more fun) : Epitech API IONIS EDUCATION GROUP : IONIS EDUCATION GROUP","title":"Links"},{"location":"about_epitech/links_docs/#documents","text":"Here you will find a list of important documents which will be useful to you during your course. https://intra.epitech.eu/file/public/","title":"Documents"},{"location":"about_us/contribution/","text":"Contributing Fork it! Create your feature branch: git checkout -b my-new-feature Commit your changes: git commit -am 'Add some feature' Push to the branch: git push origin my-new-feature Submit a pull request","title":"Contribution"},{"location":"about_us/epitools/","text":"EPITOOLS \ud83d\udc77 EPITOOLS DESCRIPTION Epitools is a kind of club of Epitech students which notice that Epitech is sometimes a few hard to understand. So we decide to help the next promotion to get all they need to start quickly and to be able to go in more difficult challenges. Maybe we like you.. or not \ud83d\udc86. PROJECTS Epitech Documentation Discord Channel CleanSFML EpiChat","title":"EPITOOLS"},{"location":"about_us/epitools/#epitools","text":"","title":"EPITOOLS \ud83d\udc77"},{"location":"about_us/epitools/#epitools-description","text":"Epitools is a kind of club of Epitech students which notice that Epitech is sometimes a few hard to understand. So we decide to help the next promotion to get all they need to start quickly and to be able to go in more difficult challenges. Maybe we like you.. or not \ud83d\udc86.","title":"EPITOOLS DESCRIPTION"},{"location":"about_us/epitools/#projects","text":"Epitech Documentation Discord Channel CleanSFML EpiChat","title":"PROJECTS"},{"location":"about_us/license/","text":"License MIT","title":"LICENSE"},{"location":"c_programming/functions/","text":"Some useful functions at epitech, workshoplib","title":"Simples functions"},{"location":"c_programming/libmy/","text":"Do you want to use your library in all your project? You can 2 makefile, 1 for the library, and another to compile all the projects","title":"Your library"},{"location":"c_programming/unit_test/","text":"Basic of Unit testing Very important at EPITECH","title":"Unit Test"},{"location":"install_config/dual_boot/","text":"Installations and configurations Installations At Epitech you will be provided at the beginning of the year with a PC with 1 TB (Terabyte) of memory and 8 GB of RAM storage. As operating system Epitech will offer you fedora and windows to install. Here we are going to see together step by step how to install in dual boot the Windows and linux systems (debian or fedora). Without further ado we will start by installing windows 10. Windows Windows is a range of full-fledged operating systems produced by Microsoft for PCs. We will start with the installation of Windows. You are going to wonder why Windows first? Well It is because of the Grub which is a computer boot program, its role is to organize the loading of the operating systems installed on the computer; it allows you to choose when booting the system on which you want to boot. The Windows Grub cannot allow us to see all the systems which are installed on the pc whereas a linux system does. By default the computer starts on the system grub installed in the last position, which then justifies the choice of the installation order which is: Windows first then comes the linux distribution that we want to install. An example of Grub: Fedora's grub First of all before starting the installation of windows you must first do what is called booting a key on windows (ie booting the usb key with the iso of windows 10). Epitech will provide you with a key already booting on Windows but in the event that you do not have a key already booting on Windows it is then up to you to boot a key (at least 8 GB). Step 1 Insert the key in the pc and start the pc set the language and you will see a window like the one below, click on install now Step 2 This is to enter an activation key that allows you to activate your Windows. The activation key is from Epitech is: Step 3 We are now at the most important part, partitioning the hard drive. I remind you that I said at the beginning that we want to install two dual-boot systems on the pc. We will then divide the disk into two large partitions. To do this : 1. Click on **new**; 2. Enter the value of the new partition in bytes and validate; 3. choose the partition and click **next** and the partitions will be created automatically.","title":"Windows + Linux Distro"},{"location":"install_config/dual_boot/#installations-and-configurations","text":"","title":"Installations and configurations"},{"location":"install_config/dual_boot/#installations","text":"At Epitech you will be provided at the beginning of the year with a PC with 1 TB (Terabyte) of memory and 8 GB of RAM storage. As operating system Epitech will offer you fedora and windows to install. Here we are going to see together step by step how to install in dual boot the Windows and linux systems (debian or fedora). Without further ado we will start by installing windows 10.","title":"Installations"},{"location":"install_config/dual_boot/#windows","text":"Windows is a range of full-fledged operating systems produced by Microsoft for PCs. We will start with the installation of Windows. You are going to wonder why Windows first? Well It is because of the Grub which is a computer boot program, its role is to organize the loading of the operating systems installed on the computer; it allows you to choose when booting the system on which you want to boot. The Windows Grub cannot allow us to see all the systems which are installed on the pc whereas a linux system does. By default the computer starts on the system grub installed in the last position, which then justifies the choice of the installation order which is: Windows first then comes the linux distribution that we want to install. An example of Grub: Fedora's grub First of all before starting the installation of windows you must first do what is called booting a key on windows (ie booting the usb key with the iso of windows 10). Epitech will provide you with a key already booting on Windows but in the event that you do not have a key already booting on Windows it is then up to you to boot a key (at least 8 GB).","title":"Windows"},{"location":"install_config/dual_boot/#step-1","text":"Insert the key in the pc and start the pc set the language and you will see a window like the one below, click on install now","title":"Step 1"},{"location":"install_config/dual_boot/#step-2","text":"This is to enter an activation key that allows you to activate your Windows. The activation key is from Epitech is:","title":"Step 2"},{"location":"install_config/dual_boot/#step-3","text":"We are now at the most important part, partitioning the hard drive. I remind you that I said at the beginning that we want to install two dual-boot systems on the pc. We will then divide the disk into two large partitions. To do this : 1. Click on **new**; 2. Enter the value of the new partition in bytes and validate; 3. choose the partition and click **next** and the partitions will be created automatically.","title":"Step 3"},{"location":"install_config/dump/","text":"Epitech Dump: Small installation guide The script available on the following repository Kayofeld Repository is perfect for the epitech dump. Aller sur github Cloner le repo Exc\u00e9cutez correctement Installer make et cmake ( sudo apt install make cmake ou sudo dnf install make cmake ) V\u00e9rifier que tout marche: emacs configuration ok ? git configuration ok ? blih fonctionnel ok ? NB: Ce script n'inclue pas la CSFML ou la SFML.","title":"EPITECH DUMP"},{"location":"install_config/dump/#epitech-dump-small-installation-guide","text":"The script available on the following repository Kayofeld Repository is perfect for the epitech dump. Aller sur github Cloner le repo Exc\u00e9cutez correctement Installer make et cmake ( sudo apt install make cmake ou sudo dnf install make cmake ) V\u00e9rifier que tout marche: emacs configuration ok ? git configuration ok ? blih fonctionnel ok ? NB: Ce script n'inclue pas la CSFML ou la SFML.","title":"Epitech Dump: Small installation guide"},{"location":"tools_cheatsheet/blih/","text":"The Bocal Lightweight Interface for Humans, BLIH is the EPITECH repository management tool. A student from the class of 2021 created a WEB interface called BLIH web . Throughout the school year, you're going to have to submit projects on Epitech servers. If you have used the kayofeld script , you are a winner . The script installs the BLIH and configures the necessary. Else, following these steps : Generate a new key, that is stored as a file and will allow you to authenticate yourself on the submittal system and secure the data exchanges. Here, you will leave all of the default values by simply pressing enter each time. $ ssh-keygen By default, the ssh key was generated in a file on your pc, in your home ~/.ssh/. $ ls ~/.ssh/ You can see in this folder (~/.ssh), there are two files. Now all you have to do is link your ssh key to blih by using this command, and enter your UNIX password (Epitech Password) $ blih -u \"surname.name@epitech.eu\" sshkey upload ~/.ssh/id_rsa.pub Now, BLIH is ready to be used. You can create a repository using: $ blih -u \"surname.name@epitech.eu\" repository create repo_name repo_name: for example, CPool_Day01_2020 To give read permissions to Nao Marvin $ blih -u \"surname.name@epitech.eu\" repository setacl repo_name ramassage_tek r If you work with another person in the project, you can give him person using: $ blih -u \"surname.name@epitech.eu\" repository setacl repo_name hisSurname.hisName@epitech.eu rwx Note that r is for read, w for write et x for excute. If you want to see who has permissions in your repo, you can type: $ blih -u \"surname.name@epitech.eu\" repository getacl repo_name If you want to delete a repo, $ blih -u \"surname.name@epitech.eu\" repository delete repo_name There are other commands, you can type $ blih -h You can find the official repo of blih here . You can also use ezblih For that, you need node and npm. You can install it here depending on your os. Node Installer To install ezblih, $ sudo npm i -g ezblih Upload your ssh-keygen with $ ssh-keygen and press Enter 3 times. Then, type, $ ezb upload The commands of ezblih are not very different from those of blih. It's just simpler. You can do the same actions as before using the commands below. ezblih will do the work for you. Use the following commands preceded by ezblih . upload create repo_name setacl repo_name user rights getacl repo_name delete repo_name If you don't want to type your email and password for each command, you can create an .env file in an ezblih folder that you also created in your home directory. ~/ezblih/.env Then fill the .env file with the content : BLIH_EMAIL=surname.name@epitech.eu BLIH_PASSWORD=your_password It is possible to fill only the email, in this case only the password will be asked. You can find the official repo of ezblih here . A simple script can be used to retrieve your old repo: Using Blih for repo in `blih repository list`; do git clone $USER@git.epitech.eu:/$USER/$repo; done Using ezblih for repo in `ezblih list`; do git clone $USER@git.epitech.eu:/$USER/$repo; done $USER is your epitech login This script retrieves all the repositories present on blih in the current directory. This procedure can therefore take some time. You can also access all your repo on this site Blih Web","title":"Blih"},{"location":"tools_cheatsheet/coding_style/","text":"Some tools to check if the coding style is good and how to fix it if not","title":"Coding Style"},{"location":"tools_cheatsheet/csfml/","text":"How to understand and start 2D game \ud83d\udc7e Understand the game A 2D game is mainly a kind of program which generally follow a guideline. It is made with 3 main parts: Initialization Game loop Free resources You notice the game core is the game loop. But we will describe the two others parts. Initialization In this part you load in memory all the component you want to use inside your game loop. You have to initialize the variables you want to use with the right element, sprite, sound, image, text, all your asset and whatever you want to use inside the game. It is also here you will fix the position of your assets (for example you will set the positions of all the assets, probably decide if you want to play the main sound of your game as soon as the game start). It is important to do this part before the game loop. Game loop The game loop is the main part of the game. It is here you will implement the game logic, manage events and also where you will draw the assets. By game logic, I mean all the game \"itself\". It is here you will define how the player will move, how the score will be displayed, what will happen if the player clicks on \"Play\" button, etc... It is here where you will define whatever should happen according to events. An event could be a keyboard input, collision between two objects, when a click happens and others such things. So the game loop is divided in three parts: event loop : where you manage all the events which will happen in the game , update : where live the game logic, drawing : the part where you draw all the asset you want in the game. You could follow this way to correctly setup or organize your future game project. Free resources In this part you free (if necessary.. because it depends on your programming language) the all the memory you should have used in your game This just an overview of the organization of a video game project. It may change depend on the game engine and barely of the framework you use. So feel free to follow the way you want to follow Set up the game in CSFML Basics Let go to a new step. You wanna create a game. Let make first a simple window. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } int main() { sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; while (sfRenderWindow_isOpen(window)) { sfRenderWindow_clear(window, sfBlack); while (sfRenderWindow_pollEvent(window, &event)) { if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); } sfRenderWindow_display(window); } sfRenderWindow_destroy(window); } Put this code inside a file, file_name.c . You can compile this code with gcc file_name.c -lcsfml-graphics -lcsfml-window . If you launched it, you will see a black window. Simple and basic. Explanation Let explain this pretty code you've compiled. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> Those lines refer to the main include you will use for all your Epitech game project. It contains all you need for graphic, sound, manage user key input, etc.... sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } This function will be very useful through all the MUL projects you will build this year. It take in parameters the width, the height and the title of the screen. Inside, sfRenderWindow *Window refers to the window where all the game will be played, sfVideoMode mode refers to the screen's configuration (the width, the height and the number of bits per pixel which impact the global window's resolution). sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; I guess you can understand that... Don't be stupid :smirk:! while (sfRenderWindow_isOpen(window)) This is the main loop of the game, which run while window is not closed. It can be replace also by while(running) with running a boolean value set to true . Close the window is so the same as set running to false . sfRenderWindow_clear(window, sfBlack); This line allows screen to refresh every time all the actions you declare in the game loop ended. It make sure you will not have an error in your displaying. It also provide a way to set a custom background color. while (sfRenderWindow_pollEvent(window, &event)) It this loop, you will be able to handle every event which should happens at least one time such collision, user input and may other things. if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); This condition is just : \" If the event which happens is sfEvtClosed (if the user want to close the window by clicking on the red cross button on the top of your window), close the game's render window. \" sfRenderWindow_display(window); This line allows you to continue to display the game's window as the game is going on. sfRenderWindow_destroy(window); This line free the resources allocated to display the window. It is a VERY IMPORTANT STEP . It makes your program more stable and able to run with much amount of variables and data. How to use correctly the documentation There is no tutorials about CSFML on internet. The only one you will find is an portuguese video tutorial about it. But it still a few useless when you look at the amount of work you will have to achieve. The right way to use the documentation... That is a great deal to handle this year in graphical programming... 5 credits for the first semester and 9 for the second one. So I will give you some tips about it. The first thing you have to handle is the logic of the documentation. All the .h files located in the File tab. If you're looking for some functions about audio management, you have to search the Audio.h file documentation. And if you need something about sprite handling: Sprite.h , about keyboard management: Keyboard.h . By doing this you'll be able to easily find your way through this documentation. Other tips: Take time to read it . It is not difficult. And if you take time just to understand the way everything is going on through this docs, you'll easily be able to understand a lot about 2D game's logic. More tips and help If you want more tricks about CSFML... Don't hesitate to visit CleanSFML project.","title":"Csfml Library"},{"location":"tools_cheatsheet/csfml/#how-to-understand-and-start-2d-game","text":"","title":"How to understand and start 2D game \ud83d\udc7e"},{"location":"tools_cheatsheet/csfml/#understand-the-game","text":"A 2D game is mainly a kind of program which generally follow a guideline. It is made with 3 main parts: Initialization Game loop Free resources You notice the game core is the game loop. But we will describe the two others parts. Initialization In this part you load in memory all the component you want to use inside your game loop. You have to initialize the variables you want to use with the right element, sprite, sound, image, text, all your asset and whatever you want to use inside the game. It is also here you will fix the position of your assets (for example you will set the positions of all the assets, probably decide if you want to play the main sound of your game as soon as the game start). It is important to do this part before the game loop. Game loop The game loop is the main part of the game. It is here you will implement the game logic, manage events and also where you will draw the assets. By game logic, I mean all the game \"itself\". It is here you will define how the player will move, how the score will be displayed, what will happen if the player clicks on \"Play\" button, etc... It is here where you will define whatever should happen according to events. An event could be a keyboard input, collision between two objects, when a click happens and others such things. So the game loop is divided in three parts: event loop : where you manage all the events which will happen in the game , update : where live the game logic, drawing : the part where you draw all the asset you want in the game. You could follow this way to correctly setup or organize your future game project. Free resources In this part you free (if necessary.. because it depends on your programming language) the all the memory you should have used in your game This just an overview of the organization of a video game project. It may change depend on the game engine and barely of the framework you use. So feel free to follow the way you want to follow","title":"Understand the game"},{"location":"tools_cheatsheet/csfml/#set-up-the-game-in-csfml","text":"","title":"Set up the game in CSFML"},{"location":"tools_cheatsheet/csfml/#basics","text":"Let go to a new step. You wanna create a game. Let make first a simple window. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } int main() { sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; while (sfRenderWindow_isOpen(window)) { sfRenderWindow_clear(window, sfBlack); while (sfRenderWindow_pollEvent(window, &event)) { if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); } sfRenderWindow_display(window); } sfRenderWindow_destroy(window); } Put this code inside a file, file_name.c . You can compile this code with gcc file_name.c -lcsfml-graphics -lcsfml-window . If you launched it, you will see a black window. Simple and basic.","title":"Basics"},{"location":"tools_cheatsheet/csfml/#explanation","text":"Let explain this pretty code you've compiled. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> Those lines refer to the main include you will use for all your Epitech game project. It contains all you need for graphic, sound, manage user key input, etc.... sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } This function will be very useful through all the MUL projects you will build this year. It take in parameters the width, the height and the title of the screen. Inside, sfRenderWindow *Window refers to the window where all the game will be played, sfVideoMode mode refers to the screen's configuration (the width, the height and the number of bits per pixel which impact the global window's resolution). sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; I guess you can understand that... Don't be stupid :smirk:! while (sfRenderWindow_isOpen(window)) This is the main loop of the game, which run while window is not closed. It can be replace also by while(running) with running a boolean value set to true . Close the window is so the same as set running to false . sfRenderWindow_clear(window, sfBlack); This line allows screen to refresh every time all the actions you declare in the game loop ended. It make sure you will not have an error in your displaying. It also provide a way to set a custom background color. while (sfRenderWindow_pollEvent(window, &event)) It this loop, you will be able to handle every event which should happens at least one time such collision, user input and may other things. if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); This condition is just : \" If the event which happens is sfEvtClosed (if the user want to close the window by clicking on the red cross button on the top of your window), close the game's render window. \" sfRenderWindow_display(window); This line allows you to continue to display the game's window as the game is going on. sfRenderWindow_destroy(window); This line free the resources allocated to display the window. It is a VERY IMPORTANT STEP . It makes your program more stable and able to run with much amount of variables and data.","title":"Explanation"},{"location":"tools_cheatsheet/csfml/#how-to-use-correctly-the-documentation","text":"There is no tutorials about CSFML on internet. The only one you will find is an portuguese video tutorial about it. But it still a few useless when you look at the amount of work you will have to achieve. The right way to use the documentation... That is a great deal to handle this year in graphical programming... 5 credits for the first semester and 9 for the second one. So I will give you some tips about it. The first thing you have to handle is the logic of the documentation. All the .h files located in the File tab. If you're looking for some functions about audio management, you have to search the Audio.h file documentation. And if you need something about sprite handling: Sprite.h , about keyboard management: Keyboard.h . By doing this you'll be able to easily find your way through this documentation. Other tips: Take time to read it . It is not difficult. And if you take time just to understand the way everything is going on through this docs, you'll easily be able to understand a lot about 2D game's logic.","title":"How to use correctly the documentation"},{"location":"tools_cheatsheet/csfml/#more-tips-and-help","text":"If you want more tricks about CSFML... Don't hesitate to visit CleanSFML project.","title":"More tips and help"},{"location":"tools_cheatsheet/emacs/","text":"Dear Old Emacs \ud83d\udc74 At Epitech, the default text editor is our good old emacs. However Visual Studio Code is interfering in our relationship with emacs and is taking over from its many extensions and style. One more time, if you have used the kayofeld script, you are a winner. The script installs emacs and configures the necessary. Really good kayofeld. \ud83d\ude1c For the installation of emacs with Epitech configuration, you can use the script available in this repository github Epitech-emacs . Go to this repository, clone him and follow the steps. Emacs useful shortcuts you will use: - coding style - emacs config file","title":"Emacs"},{"location":"tools_cheatsheet/emacs/#dear-old-emacs","text":"At Epitech, the default text editor is our good old emacs. However Visual Studio Code is interfering in our relationship with emacs and is taking over from its many extensions and style. One more time, if you have used the kayofeld script, you are a winner. The script installs emacs and configures the necessary. Really good kayofeld. \ud83d\ude1c For the installation of emacs with Epitech configuration, you can use the script available in this repository github Epitech-emacs . Go to this repository, clone him and follow the steps. Emacs useful shortcuts you will use: - coding style - emacs config file","title":"Dear Old Emacs \ud83d\udc74"},{"location":"tools_cheatsheet/git/","text":"Git is a distributed version-control system for tracking changes in source code during software development, created by Linus Torvalds in 2005 for development of the Linux kernel. It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed, data integrity, and support for distributed, non-linear workflows [clarification needed]. If you have used the kayofeld script , you are a winner . After creating your repo, you will have to clone it using: $ git clone surname.name@git.epitech.eu/surname.name@git.epitech.eu/repo_name If you are not the owner of the repo, replace the second surname.name by the owner login. Now you can create a file/folder and start working. You have to use these three commands every time you want to update your repe on the server. git add your_file // you can use `.` to add all the modified files git commit -m \"commit_message\" git push origin master If you are working with someone on the project, you can retrieve the changes from the server with: git pull There are a lot of git commands to manage your code. Especially when you are working on a project together. You can see a summary of the commands you can use on these sites. Git CheatSheet Git CheatSheet by GITHUB","title":"Git"},{"location":"tools_cheatsheet/makefile/","text":"And God make Makefile \ud83d\udc86 Simple Makefile A simple Makefile. CC = gcc NAME = name_of_binary CFLAGS = -Wpedantic -pedantic-errors -w -Wextra -Wall -Iinclude SRC = core/my_printf.c \\ core/save_printf.c \\ src/my_putstr.c \\ src/my_putchar.c \\ src/my_strlen.c \\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) -c $(OBJ) ar rc $(NAME) $(OBJ) clean: rm -f $(OBJ) fclean: clean rm -f $(NAME) re: fclean all .PHONY: fclean clean re Graphical Makefile Template In this template I have a folder named src where is located all my .c file except the main.c which is root located. The $(shell find src/ -name ' .c') means to Makefile to find all the .c files which are located in the folder src* including all the sub directory inside it. CC = gcc CSFML += -lcsfml-graphics -lcsfml-window -lcsfml-audio -lcsfml-system CFLAGS += -Wpedantic -pedantic-errors -w -Wextra -Wall $(CSFML) -Iinc NAME = name_of_the_binary SRC = $(shell find src/ -name '*.c')\\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) $(CFLAGS) $(OBJ) $(LIB) -o $(NAME) rm -f $(OBJ) *~ clean: rm -f src/*.o rm -f *~ core/*~ inc/*~ src/*~ fclean: clean rm -f $(NAME) rm -f a.out src/a.out core/a.out a.out re: fclean all .PHONY: fclean clean re Some useful flags and possibilities of customs makefile you can use","title":"Makefile"},{"location":"tools_cheatsheet/makefile/#and-god-make-makefile","text":"","title":"And God make Makefile \ud83d\udc86"},{"location":"tools_cheatsheet/makefile/#simple-makefile","text":"A simple Makefile. CC = gcc NAME = name_of_binary CFLAGS = -Wpedantic -pedantic-errors -w -Wextra -Wall -Iinclude SRC = core/my_printf.c \\ core/save_printf.c \\ src/my_putstr.c \\ src/my_putchar.c \\ src/my_strlen.c \\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) -c $(OBJ) ar rc $(NAME) $(OBJ) clean: rm -f $(OBJ) fclean: clean rm -f $(NAME) re: fclean all .PHONY: fclean clean re","title":"Simple Makefile"},{"location":"tools_cheatsheet/makefile/#graphical-makefile-template","text":"In this template I have a folder named src where is located all my .c file except the main.c which is root located. The $(shell find src/ -name ' .c') means to Makefile to find all the .c files which are located in the folder src* including all the sub directory inside it. CC = gcc CSFML += -lcsfml-graphics -lcsfml-window -lcsfml-audio -lcsfml-system CFLAGS += -Wpedantic -pedantic-errors -w -Wextra -Wall $(CSFML) -Iinc NAME = name_of_the_binary SRC = $(shell find src/ -name '*.c')\\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) $(CFLAGS) $(OBJ) $(LIB) -o $(NAME) rm -f $(OBJ) *~ clean: rm -f src/*.o rm -f *~ core/*~ inc/*~ src/*~ fclean: clean rm -f $(NAME) rm -f a.out src/a.out core/a.out a.out re: fclean all .PHONY: fclean clean re Some useful flags and possibilities of customs makefile you can use","title":"Graphical Makefile Template"},{"location":"tools_cheatsheet/ncurses/","text":"All the basics tools of ncurses lib","title":"Ncurses Library"}]}