{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EPITECH Documentation Table of Content I. ABOUT EPITECH Epitech PEDAGOGY Links & Documents II. INSTALLATIONS & CONFIGURATIONS Windows + Linux Distro EPITECH DUMP III. TOOLS CHEATSHEET Blih Git Emacs Gcc Makefile Coding style TTY IV. C PROGRAMMING Simples functions Libraries Csfml Library Ncurses Library Your library Notions Structures Lists Pointers Unit Test V. ABOUT US EPITOOLS Contribution License First solve the problem. Then, write the code. \u2013 John Johnson","title":"HOME"},{"location":"#welcome-to-epitech-documentation","text":"","title":"Welcome to EPITECH Documentation"},{"location":"#table-of-content","text":"I. ABOUT EPITECH Epitech PEDAGOGY Links & Documents II. INSTALLATIONS & CONFIGURATIONS Windows + Linux Distro EPITECH DUMP III. TOOLS CHEATSHEET Blih Git Emacs Gcc Makefile Coding style TTY IV. C PROGRAMMING Simples functions Libraries Csfml Library Ncurses Library Your library Notions Structures Lists Pointers Unit Test V. ABOUT US EPITOOLS Contribution License First solve the problem. Then, write the code. \u2013 John Johnson","title":"Table of Content"},{"location":"about_epitech/epitech/","text":"Description Epitech is a really different school from the ones we are used to seeing. l takes place over 5 years and trains professional and ready-to-use IT experts. It offers dense and varied technical content, including a diversity of programming projects, and covering many languages that will allow the student to approach all new technologies with serenity. \u201cAt the end of the five-year course, the Epitech student is an expert in computer science, autonomous, responsible and perfectly adaptable to the business world. As he or she is technically speaking ultra-competent, the student obviously knows how to create and combine ideas and technology, but also how to surround themselves with the best partners to direct their projects. In a world that is in permanent evolution and where innovation dictates the rules, the student also has the necessary ammunition that is essential in order to succeed.\u201d Emmanuel Carli, General Director A two-cycle program The 1st Cycle: three years for the Epitech Bachelor Degree { Fundamentals || Consolidation || Mastery } The most noticeable aspect of the first two years is without doubt the omnipresent technique, seen across numerous large-scale projects of varied complexities. In order to reach this aspired level, Epitech students are confronted with a heavy workload and demanding rigour. Over and above the purely technical aspect, this learning method provides a real individual structure for the students. It forges their personal organisation, tests their perseverance and creates a real group work culture and collective success. By relying on the solid base put in place in the 1st and 2nd years, the 3rd year at Epitech provides a quick and easy access to many computer domains (artificial intelligence, databases, security, advanced object orientation programming, network, and so on). In order to reach operational level in a company leading to the Epitech Bachelor in Information Technology, the 3rd year makes it possible to bring together the big players in the market (Microsoft, Oracle, Cisco). The bases of the economic and relations mechanisms in a business are approached so as to allow the students to gain a good understanding of the economic context (commerce, communication, marketing, finance, law, etc). The 2nd cycle, or Expertise cycle, lasts 2 years : { Internationalization || Leadership } The international dimension is essential at Epitech. The 4th year takes place entirely abroad, in one of our 90 partner universities. On the programme: discovering new cultures, observing one\u2019s own country from abroad, learning new teaching methods and expanding one\u2019s network. In a globalized world, a high-level career, especially in computer science, cannot be achieved in the absence of an international dimension. During this period, Epitech students are immersed in the heart of a new working environment and can choose the courses best suited to their career project and their centres of interest. They continue to work as a team on their Epitech Innovative Project, remotely and far from each other, as they would be led to do if they joined an international company. During this last year, the students are inspired by more than 50 seminars given by high-level speakers: academics or professionals, French or foreign\u2026 They address topics as varied as the analysis of data, quantum computing, innovation management or artificial intelligence\u2026 At the same time, students work 3 days a week in a company and do a 6-month internship at the end of the course \u2013 two real bridges to the professional world. Those whose EIP project is already completed can also choose to devote this time to starting a business. This 5th year also sees the completion of 3 years of teamwork on the main project of the Epitech curriculum: The Epitech Innovative Project. Opportunities DEVOPS : Merger of developer and system administrator DEVELOPER: He/She is responsible for programming using computer languages, such as C++ or JAVA PROJECT MANAGER: He/She translates customer requests into IT Solutions CTO: He/She is in charge of the technological innovation of the company QUALITY ASSURANCE ENGINEER: He/She ensures the quality of software development and provides recommendations IT ARCHITECT: He/She designs and develops information systems, hardware, software, networks.","title":"Epitech PEDAGOGY"},{"location":"about_epitech/epitech/#description","text":"Epitech is a really different school from the ones we are used to seeing. l takes place over 5 years and trains professional and ready-to-use IT experts. It offers dense and varied technical content, including a diversity of programming projects, and covering many languages that will allow the student to approach all new technologies with serenity. \u201cAt the end of the five-year course, the Epitech student is an expert in computer science, autonomous, responsible and perfectly adaptable to the business world. As he or she is technically speaking ultra-competent, the student obviously knows how to create and combine ideas and technology, but also how to surround themselves with the best partners to direct their projects. In a world that is in permanent evolution and where innovation dictates the rules, the student also has the necessary ammunition that is essential in order to succeed.\u201d Emmanuel Carli, General Director","title":"Description"},{"location":"about_epitech/epitech/#a-two-cycle-program","text":"","title":"A two-cycle program"},{"location":"about_epitech/epitech/#the-1st-cycle-three-years-for-the-epitech-bachelor-degree","text":"{ Fundamentals || Consolidation || Mastery } The most noticeable aspect of the first two years is without doubt the omnipresent technique, seen across numerous large-scale projects of varied complexities. In order to reach this aspired level, Epitech students are confronted with a heavy workload and demanding rigour. Over and above the purely technical aspect, this learning method provides a real individual structure for the students. It forges their personal organisation, tests their perseverance and creates a real group work culture and collective success. By relying on the solid base put in place in the 1st and 2nd years, the 3rd year at Epitech provides a quick and easy access to many computer domains (artificial intelligence, databases, security, advanced object orientation programming, network, and so on). In order to reach operational level in a company leading to the Epitech Bachelor in Information Technology, the 3rd year makes it possible to bring together the big players in the market (Microsoft, Oracle, Cisco). The bases of the economic and relations mechanisms in a business are approached so as to allow the students to gain a good understanding of the economic context (commerce, communication, marketing, finance, law, etc).","title":"The 1st Cycle: three years for the Epitech Bachelor Degree"},{"location":"about_epitech/epitech/#the-2nd-cycle-or-expertise-cycle-lasts-2-years","text":"{ Internationalization || Leadership } The international dimension is essential at Epitech. The 4th year takes place entirely abroad, in one of our 90 partner universities. On the programme: discovering new cultures, observing one\u2019s own country from abroad, learning new teaching methods and expanding one\u2019s network. In a globalized world, a high-level career, especially in computer science, cannot be achieved in the absence of an international dimension. During this period, Epitech students are immersed in the heart of a new working environment and can choose the courses best suited to their career project and their centres of interest. They continue to work as a team on their Epitech Innovative Project, remotely and far from each other, as they would be led to do if they joined an international company. During this last year, the students are inspired by more than 50 seminars given by high-level speakers: academics or professionals, French or foreign\u2026 They address topics as varied as the analysis of data, quantum computing, innovation management or artificial intelligence\u2026 At the same time, students work 3 days a week in a company and do a 6-month internship at the end of the course \u2013 two real bridges to the professional world. Those whose EIP project is already completed can also choose to devote this time to starting a business. This 5th year also sees the completion of 3 years of teamwork on the main project of the Epitech curriculum: The Epitech Innovative Project.","title":"The 2nd cycle, or Expertise cycle, lasts 2 years :"},{"location":"about_epitech/epitech/#opportunities","text":"DEVOPS : Merger of developer and system administrator DEVELOPER: He/She is responsible for programming using computer languages, such as C++ or JAVA PROJECT MANAGER: He/She translates customer requests into IT Solutions CTO: He/She is in charge of the technological innovation of the company QUALITY ASSURANCE ENGINEER: He/She ensures the quality of software development and provides recommendations IT ARCHITECT: He/She designs and develops information systems, hardware, software, networks.","title":"Opportunities"},{"location":"about_epitech/links_docs/","text":"Links Most of these links can only be accessed with your Office 365 credentials provided when registering for EPITECH. OFFICIEL WEBSITE : https://epitech.eu/ INTRA : https://intra.epitech.eu/ Nao Marvin : https://my.epitech.eu/ ENGLISH : https://www.altissia.org/ OFFICE : https://www.office.com/ GITHUB : https://education.github.com/pack VMWARE : https://www.vmware.com/products.html JETBRAINS : https://www.jetbrains.com/ LIBRARY : http://www.scholarvox.com/ TIMELINE AND MIRROR FOR YOUR PROJECTS : https://roslyn.epi.codes/ BLIH WEB : https://blih.saumon.io/ EPITECH JOB TEASER : https://epitech.jobteaser.com/fr/users/sign_in EPITECH INNOVATIVE PROJECT : https://eip.epitech.eu/#/login EPITECH HUB : http://hub.epitech.eu/#/ EPITECH ALUMNI : http://epitech-alumni.org/ International Epitech platform : https://tekfeed.epitech.eu/#/ EPITECH DOCUMENTATION : https://epitech-2022-technical-documentation.readthedocs.io/en/latest/# EPITECH PROJECT : https://github.com/epitools2024/EPITECH_PROJECTS.git EPITECH DOCUMENTATION : https://github.com/epitools2024/EPITECH-DOCUMENTATION.git EPITECH API DOCUMENTATION (Just for more fun) : Epitech API IONIS EDUCATION GROUP : IONIS EDUCATION GROUP Documents Here you will find a list of important documents which will be useful to you during your course. https://intra.epitech.eu/file/public/","title":"Links & Documents"},{"location":"about_epitech/links_docs/#links","text":"Most of these links can only be accessed with your Office 365 credentials provided when registering for EPITECH. OFFICIEL WEBSITE : https://epitech.eu/ INTRA : https://intra.epitech.eu/ Nao Marvin : https://my.epitech.eu/ ENGLISH : https://www.altissia.org/ OFFICE : https://www.office.com/ GITHUB : https://education.github.com/pack VMWARE : https://www.vmware.com/products.html JETBRAINS : https://www.jetbrains.com/ LIBRARY : http://www.scholarvox.com/ TIMELINE AND MIRROR FOR YOUR PROJECTS : https://roslyn.epi.codes/ BLIH WEB : https://blih.saumon.io/ EPITECH JOB TEASER : https://epitech.jobteaser.com/fr/users/sign_in EPITECH INNOVATIVE PROJECT : https://eip.epitech.eu/#/login EPITECH HUB : http://hub.epitech.eu/#/ EPITECH ALUMNI : http://epitech-alumni.org/ International Epitech platform : https://tekfeed.epitech.eu/#/ EPITECH DOCUMENTATION : https://epitech-2022-technical-documentation.readthedocs.io/en/latest/# EPITECH PROJECT : https://github.com/epitools2024/EPITECH_PROJECTS.git EPITECH DOCUMENTATION : https://github.com/epitools2024/EPITECH-DOCUMENTATION.git EPITECH API DOCUMENTATION (Just for more fun) : Epitech API IONIS EDUCATION GROUP : IONIS EDUCATION GROUP","title":"Links"},{"location":"about_epitech/links_docs/#documents","text":"Here you will find a list of important documents which will be useful to you during your course. https://intra.epitech.eu/file/public/","title":"Documents"},{"location":"about_us/contribution/","text":"Contributing Fork it! Create your feature branch: git checkout -b my-new-feature Commit your changes: git commit -am 'Add some feature' Push to the branch: git push origin my-new-feature Submit a pull request","title":"Contribution"},{"location":"about_us/epitools/","text":"DESCRIPTION\ud83d\udc77 Epitools is a kind of club of Epitech students which notice that Epitech is sometimes a few hard to understand. So we decide to help the next promotion to get all they need to start quickly and to be able to go in more difficult challenges. Maybe we like you.. or not \ud83d\udc86. PROJECTS Epitech Documentation EPITOOLS Discord Chanel CleanSFML EpiChat EPIGUYS TEAM Hamidou TESSILIMI Basilia TOMEHO Junior MEDEHOU Charmeel VODOUHE Prince MIYIGBENA","title":"EPITOOLS"},{"location":"about_us/license/","text":"MIT License Copyright (c) [2020] [EPITOOLS] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"c_programming/functions/","text":"Welcome to the necessary functions section in C for a student from Epitech. As the title indicates, in this section we will especially talk about some necessary functions in C for a student from Epitech. Let's go !!! 1. Hello World If you don't know it, it has become a tradition in the developer culture to start learning a new language by writing a function displaying the message \"Hello World\". More ... int main(int ac, char **av) { int fd = 1; // fd is the file descriptor (see man page of write) int n = 12; // n is the number of characters of the string to print write(fd, \"Hello World\\n\", n); return (0); } 2. my_putchar my_putchar is one of the first functions to be coded in C at Epitech. It takes a single parameter, a character, which it then displays on the standard output. -[x] Prototype : void my_putchar(char c); -[x] Output : The character passed as a parameter. -[x] Return : Anything 3. my_strlen my_strlen is a function that counts and returns the number of characters found in the string passed as parameter. -[x] Prototype : int my_strlen(char const *str); -[x] Output : Nothing on the standard output. -[x] Return : A int that represents number of characters found in the string passed as parameter. 4. my_putstr my_putstr is a function that displays, one-by-one, the characters of a string. The address of the string\u2019s first character will be found in the pointer passed as a parameter to the function. -[x] Prototype : void my_putstr(char const *str); OR int my_putstr (char const *str); -[x] Output : Display the string passed as a parameter. -[x] Return : Anything in the first case and O or 1 in the second case. 5. my_putnbr my_putnbr is a function that displays a number ( a int ) passed as a parameter. -[x] Prototype : int my_put_nbr(int nb); -[x] Output : Display the number passed as a parameter. -[x] Return : O or 1 by default. 6. my_getnbr my_getnbr is a function that returns a number, sent as a string. -[x] Prototype : int my_getnbr(char const *str); -[x] Output : Anything . -[x] Return : Return a number sent as a string. 7. my_strcpy my_strcpy is a function that copies a string into another. The destination string will already have enough memory to copy the source string. -[x] Prototype : char *my_strcpy(char *dest, char const *src); -[x] Output : Anything . -[x] Return : The string. 8. my_strcmp my_strcmp is a function that compares two strings character by character. -[x] Prototype : int my_strcmp(char const *s1, char const *s2); -[x] Output : Anything . -[x] Return : 0 if both strings are the same else 1. 9. my_strcat my_strcat is a function that concatenates two strings passed as parameters. -[x] Prototype : char *my_strcat(char *dest, char const *src); -[x] Output : Anything . -[x] Return : The chain resulting from the concatenation. 10. my_str_to_word_array my_str_to_word_array is a function that splits a string into words arranged in order in a double table. -[x] Prototype : char **my_str_to_word_array(char const *str); -[x] Output : Anything . -[x] Return : The double table with the strings resulting from the parsing of the chain.","title":"Simples functions"},{"location":"c_programming/helloworld_knowmore/","text":"Deux petits mots pour le code, un grand mythe pour l\u2019informatique. \u00ab Hello world \u00bb \u00e9tait l\u2019exemple de phrase donn\u00e9e dans le manuel d\u2019usage The C Programming Language, pour tester une fonction. La popularit\u00e9 du langage et du livre a par l\u2019usage rendu populaire l\u2019utilisation de ces deux mots pr\u00e9cis pour tester une fonction. Oui, mais pourquoi ces deux mots ? Et pourquoi pas simplement \u00ab test 1 fonction \u00bb, par exemple ? \u00c0 l\u2019instar du Big bang, l\u2019origine d\u2019Hello world reste flou. Des propres aveux de Brian Kernighan dans une interview accord\u00e9e \u00e0 Forbes, \u00ab sa m\u00e9moire d\u00e9faille \u00bb. Cependant il semble que les termes soient tir\u00e9s d\u2019un dessin anim\u00e9 qu\u2019il avait vu \u00e0 l\u2019\u00e9poque. Dans le dessin anim\u00e9, un poussin sortait de son \u0153uf en s\u2019\u00e9criant \u00ab Hello world \u00bb. Info ou mytho, quoi qu\u2019il en soit, le choix des termes et le contexte semblent contribuer \u00e0 une certaine mythologie du langage, sorte de symbole de la naissance de celui-ci. Si l\u2019utilisation encore aujourd\u2019hui de ces deux mots peut \u00eatre questionn\u00e9e, il est int\u00e9ressant de se demander s\u2019ils ne sont pas devenus plus qu\u2019une tradition, un symbole. \u00ab Hello world \u00bb peut prendre des interpr\u00e9tations multiples, en particulier de nos jours. Ils ont pu au fil des ann\u00e9es et de l\u2019\u00e9volution de l\u2019informatique et d\u2019Internet renforcer une mythologie. \u00c9crire \u00ab Hello world \u00bb lors d\u2019une premi\u00e8re fonction et la voir s\u2019afficher, c\u2019est voir \u00ab na\u00eetre \u00bb son code sous ses yeux, c\u2019est \u00ab mettre au monde \u00bb celui-ci. \u00ab Hello world \u00bb, c\u2019est potentiellement cherch\u00e9 l\u2019universalit\u00e9, chercher \u00e0 atteindre tous et toutes et dans tous les pays. Aussi simple que \u00ab Bonjour \u00bb. \u00ab Hello world \u00bb, c\u2019est aussi ancrer leur usage, perp\u00e9tuer la tradition et participer \u00e0 l\u2019Histoire de l\u2019informatique.","title":"Deux petits mots pour le code, un grand mythe pour l\u2019informatique."},{"location":"c_programming/helloworld_knowmore/#deux-petits-mots-pour-le-code-un-grand-mythe-pour-linformatique","text":"\u00ab Hello world \u00bb \u00e9tait l\u2019exemple de phrase donn\u00e9e dans le manuel d\u2019usage The C Programming Language, pour tester une fonction. La popularit\u00e9 du langage et du livre a par l\u2019usage rendu populaire l\u2019utilisation de ces deux mots pr\u00e9cis pour tester une fonction. Oui, mais pourquoi ces deux mots ? Et pourquoi pas simplement \u00ab test 1 fonction \u00bb, par exemple ? \u00c0 l\u2019instar du Big bang, l\u2019origine d\u2019Hello world reste flou. Des propres aveux de Brian Kernighan dans une interview accord\u00e9e \u00e0 Forbes, \u00ab sa m\u00e9moire d\u00e9faille \u00bb. Cependant il semble que les termes soient tir\u00e9s d\u2019un dessin anim\u00e9 qu\u2019il avait vu \u00e0 l\u2019\u00e9poque. Dans le dessin anim\u00e9, un poussin sortait de son \u0153uf en s\u2019\u00e9criant \u00ab Hello world \u00bb. Info ou mytho, quoi qu\u2019il en soit, le choix des termes et le contexte semblent contribuer \u00e0 une certaine mythologie du langage, sorte de symbole de la naissance de celui-ci. Si l\u2019utilisation encore aujourd\u2019hui de ces deux mots peut \u00eatre questionn\u00e9e, il est int\u00e9ressant de se demander s\u2019ils ne sont pas devenus plus qu\u2019une tradition, un symbole. \u00ab Hello world \u00bb peut prendre des interpr\u00e9tations multiples, en particulier de nos jours. Ils ont pu au fil des ann\u00e9es et de l\u2019\u00e9volution de l\u2019informatique et d\u2019Internet renforcer une mythologie. \u00c9crire \u00ab Hello world \u00bb lors d\u2019une premi\u00e8re fonction et la voir s\u2019afficher, c\u2019est voir \u00ab na\u00eetre \u00bb son code sous ses yeux, c\u2019est \u00ab mettre au monde \u00bb celui-ci. \u00ab Hello world \u00bb, c\u2019est potentiellement cherch\u00e9 l\u2019universalit\u00e9, chercher \u00e0 atteindre tous et toutes et dans tous les pays. Aussi simple que \u00ab Bonjour \u00bb. \u00ab Hello world \u00bb, c\u2019est aussi ancrer leur usage, perp\u00e9tuer la tradition et participer \u00e0 l\u2019Histoire de l\u2019informatique.","title":"Deux petits mots pour le code, un grand mythe pour l\u2019informatique."},{"location":"c_programming/libmy/","text":"Do you want to use your library in all your project? You can 2 makefile, 1 for the library, and another to compile all the projects ar rc","title":"Your Library"},{"location":"c_programming/lists/","text":"","title":"Lists"},{"location":"c_programming/pointers/","text":"Young C programmer !!! Welcome to the world of Pointers As a C programmer from Epitech it's really important for you guys to know how to use pointers and of course this is one of the most important concept in C programming. In this documentation, you'll understand why the pointers are so important for your first year as a student from Epitech and of course how to use them correctly in order to better prepare for certain concepts such as lists. Let's do a little exercise","title":"Pointers"},{"location":"c_programming/structures/","text":"","title":"Structures"},{"location":"c_programming/unit_test/","text":"Unit tests are tests that allow you to check the correctness and efficiency of your functions. To start with we need the librairy criterion. Criterion is a unit-testing tool that will allow you to test your code efficiently. Criterion lets you create a set of tests that will be executed on your code. Install Criterion $ sudo dnf install criterion If you want your tests to work, you must compile your code with Criterion\u2019s library using the -lcriterion flag. To see the coverage you need to install gcovr $ sudo dnf install gcovr Basic of Unit testing Assert Asserts are Criterion\u2019s way of defining tests to run and all asserts are located in the header <criterion/criterion.h> . Basic asserts ./ The asserts below allows to test a function while returning a sentence if the condition is not verified. Test(suite_name, test_name) { int i = 2; cr_assert(i * 2 == 4, \"The result was %d. Expected %d\", i * 2, 4); } In this example if the condition i * 2 == j is not verified the message is displayed. cr_assert(condition) cr_assert_not(condition) If you want to compare arrays, please refer to cr_assert_str_eq() or cr_assert_arr_eq() . Redirections To use the following assertions, you must include <criterion/redirect.h> along with <criterion/criterion.h> . cr_assert_stdout_eq_str(Value) These asserts allow to compare the content of stdout with Value cr_assert_stderr_eq_str(Value) These asserts allow to compare the content of stderr with value. Here is a sample usage of this assert. #include <criterion/criterion.h> #include <criterion/redirect.h> void redirect_all_stdout(void) { cr_redirect_stdout(); cr_redirect_stderr(); } int error(void) { write(2, \"error\", 5); return(0); } Test(errors, exit_code, .init=redirect_all_stdout) { error(); cr_assert_stderr_eq_str(\"error\", \"\"); } NB: You must include criterion.h and redirect.h in this order, otherwise your tests won\u2019t work. Test options .init This parameter takes a function pointer as an argument. Criterion will execute the function just before running the test. The function pointer should be of type void(*)(void) . void my_func(void) { my_putstr(\"My test\\n\"); } Test(suite_name, test_name, .init = my_func) { //tests } .fini This parameter takes a function pointer to a function that will be executed after the tests is finished. It takes the same pointer type as the .init parameter, and also has the same usage. .exit_code If you want to test your error handling, you can use the .exit_code parameter so the test will be marked as passed if the given exit code is found. int error(void) { write(2, \"error\", 5); exit(0); } Test(errors, exit_code, .exit_code = 84) { error(); cr_assert_stderr_eq(\"error\", \"\"); } .signal If a test receives a signal, it will by default be marked as a failure. However, you can expect a test to pass if a special kind of signal is received. .disabled If it's true, the test will be skipped. .description This parameter must be used in order to give extra definition of the test\u2019s purpose, which can be quite helpful if your suite_name and test_name aren\u2019t as explicit as you would like. .timeout This parameter takes a double, representing a duration. If your test takes longer than this duration to run, the test will be marked as failed. Makefile rule for Unit Test $ gcc -o binary_name file.c tests/test_project.c -- coverage -lcriterion $ gcovr --exclude tests $ gcovr --exclude tests --branches NB: The command to execute the test units must be $ make tests_run Criterion doc epitech","title":"Unit Test"},{"location":"install_config/dual_boot/","text":"Installations and configurations Installations At Epitech you will be provided at the beginning of the year with a PC with 1 TB (Terabyte) of memory and 8 GB of RAM storage. As operating system Epitech will offer you fedora and windows to install. Here we are going to see together step by step how to install in dual boot the Windows and linux systems (debian or fedora). Without further ado we will start by installing windows 10. Windows Windows is a range of full-fledged operating systems produced by Microsoft for PCs. We will start with the installation of Windows. You are going to wonder why Windows first? Well It is because of the Grub which is a computer boot program, its role is to organize the loading of the operating systems installed on the computer; it allows you to choose when booting the system on which you want to boot. The Windows Grub cannot allow us to see all the systems which are installed on the pc whereas a linux system does. By default the computer starts on the system grub installed in the last position, which then justifies the choice of the installation order which is: Windows first then comes the linux distribution that we want to install. An example of Grub: Fedora's grub First of all before starting the installation of windows you must first do what is called booting a key on windows (ie booting the usb key with the iso of windows 10). Epitech will provide you with a key already booting on Windows but in the event that you do not have a key already booting on Windows it is then up to you to boot a key (at least 8 GB). Step 1 Insert the key in the pc and start the pc set the language and you will see a window like the one below, click on install now Step 2 This is to enter an activation key that allows you to activate your Windows. The activation key is from Epitech is: Step 3 We are now at the most important part, partitioning the hard drive. I remind you that I said at the beginning that we want to install two dual-boot systems on the pc. We will then divide the disk into two large partitions. To do this : 1. Click on **new**; 2. Enter the value of the new partition in bytes and validate; 3. choose the partition and click **next** and the partitions will be created automatically.","title":"Windows + Linux Distro"},{"location":"install_config/dual_boot/#installations-and-configurations","text":"","title":"Installations and configurations"},{"location":"install_config/dual_boot/#installations","text":"At Epitech you will be provided at the beginning of the year with a PC with 1 TB (Terabyte) of memory and 8 GB of RAM storage. As operating system Epitech will offer you fedora and windows to install. Here we are going to see together step by step how to install in dual boot the Windows and linux systems (debian or fedora). Without further ado we will start by installing windows 10.","title":"Installations"},{"location":"install_config/dual_boot/#windows","text":"Windows is a range of full-fledged operating systems produced by Microsoft for PCs. We will start with the installation of Windows. You are going to wonder why Windows first? Well It is because of the Grub which is a computer boot program, its role is to organize the loading of the operating systems installed on the computer; it allows you to choose when booting the system on which you want to boot. The Windows Grub cannot allow us to see all the systems which are installed on the pc whereas a linux system does. By default the computer starts on the system grub installed in the last position, which then justifies the choice of the installation order which is: Windows first then comes the linux distribution that we want to install. An example of Grub: Fedora's grub First of all before starting the installation of windows you must first do what is called booting a key on windows (ie booting the usb key with the iso of windows 10). Epitech will provide you with a key already booting on Windows but in the event that you do not have a key already booting on Windows it is then up to you to boot a key (at least 8 GB).","title":"Windows"},{"location":"install_config/dual_boot/#step-1","text":"Insert the key in the pc and start the pc set the language and you will see a window like the one below, click on install now","title":"Step 1"},{"location":"install_config/dual_boot/#step-2","text":"This is to enter an activation key that allows you to activate your Windows. The activation key is from Epitech is:","title":"Step 2"},{"location":"install_config/dual_boot/#step-3","text":"We are now at the most important part, partitioning the hard drive. I remind you that I said at the beginning that we want to install two dual-boot systems on the pc. We will then divide the disk into two large partitions. To do this : 1. Click on **new**; 2. Enter the value of the new partition in bytes and validate; 3. choose the partition and click **next** and the partitions will be created automatically.","title":"Step 3"},{"location":"install_config/dump/","text":"The script available on the following repository Kayofeld Repository is perfect for the epitech dump. Clone the repo and go inside the root directory. Then, $ ./install <surname.name@epitech.eu> NB: This script don't include CSFML or SFML. You can install the CSFML here","title":"EPITECH DUMP"},{"location":"tools_cheatsheet/TTY/","text":"","title":"TTY"},{"location":"tools_cheatsheet/blih/","text":"The Bocal Lightweight Interface for Humans, BLIH is the EPITECH repository management tool. A student from the class of 2021 created a WEB interface called BLIH web . Throughout the school year, you're going to have to submit projects on Epitech servers. If you have used the kayofeld script , you are a winner . The script installs the BLIH and configures the necessary. Else, following these steps : Generate a new key, that is stored as a file and will allow you to authenticate yourself on the submittal system and secure the data exchanges. Here, you will leave all of the default values by simply pressing enter each time. $ ssh-keygen By default, the ssh key was generated in a file on your pc, in your home ~/.ssh/. $ ls ~/.ssh/ You can see in this folder (~/.ssh), there are two files. Now all you have to do is link your ssh key to blih by using this command, and enter your UNIX password (Epitech Password) $ blih -u \"surname.name@epitech.eu\" sshkey upload ~/.ssh/id_rsa.pub Now, BLIH is ready to be used. You can create a repository using: $ blih -u \"surname.name@epitech.eu\" repository create repo_name repo_name: for example, CPool_Day01_2020 To give read permissions to Nao Marvin $ blih -u \"surname.name@epitech.eu\" repository setacl repo_name ramassage_tek r If you work with another person in the project, you can give him person using: $ blih -u \"surname.name@epitech.eu\" repository setacl repo_name hisSurname.hisName@epitech.eu rwx Note that r is for read, w for write et x for excute. If you want to see who has permissions in your repo, you can type: $ blih -u \"surname.name@epitech.eu\" repository getacl repo_name If you want to delete a repo, $ blih -u \"surname.name@epitech.eu\" repository delete repo_name There are other commands, you can type $ blih -h You can find the official repo of blih here . You can also use ezblih For that, you need node and npm. You can install it here depending on your os. Node Installer To install ezblih, $ sudo npm i -g ezblih Upload your ssh-keygen with $ ssh-keygen and press Enter 3 times. Then, type, $ ezb upload The commands of ezblih are not very different from those of blih. It's just simpler. You can do the same actions as before using the commands below. ezblih will do the work for you. Use the following commands preceded by ezblih . upload create repo_name setacl repo_name user rights getacl repo_name delete repo_name If you don't want to type your email and password for each command, you can create an .env file in an ezblih folder that you also created in your home directory. ~/ezblih/.env Then fill the .env file with the content : BLIH_EMAIL=surname.name@epitech.eu BLIH_PASSWORD=your_password It is possible to fill only the email, in this case only the password will be asked. You can find the official repo of ezblih here . A simple script can be used to retrieve your old repo: Using Blih for repo in `blih repository list`; do git clone $USER@git.epitech.eu:/$USER/$repo; done Using ezblih for repo in `ezblih list`; do git clone $USER@git.epitech.eu:/$USER/$repo; done $USER is your epitech login This script retrieves all the repositories present on blih in the current directory. This procedure can therefore take some time. You can also access all your repo on this site Blih Web","title":"Blih"},{"location":"tools_cheatsheet/coding_style/","text":"Some tools to check if the coding style is good and how to fix it if not NormEZ and how to use it EPITECH Coding Style","title":"Coding Style"},{"location":"tools_cheatsheet/csfml/","text":"How to understand and start 2D game \ud83d\udc7e Understand the game A 2D game is mainly a kind of program which generally follow a guideline. It is made with 3 main parts: Initialization Game loop Free resources You notice the game core is the game loop. But we will describe the two others parts. Initialization In this part you load in memory all the component you want to use inside your game loop. You have to initialize the variables you want to use with the right element, sprite, sound, image, text, all your asset and whatever you want to use inside the game. It is also here you will fix the position of your assets (for example you will set the positions of all the assets, probably decide if you want to play the main sound of your game as soon as the game start). It is important to do this part before the game loop. Game loop The game loop is the main part of the game. It is here you will implement the game logic, manage events and also where you will draw the assets. By game logic, I mean all the game \"itself\". It is here you will define how the player will move, how the score will be displayed, what will happen if the player clicks on \"Play\" button, etc... It is here where you will define whatever should happen according to events. An event could be a keyboard input, collision between two objects, when a click happens and others such things. So the game loop is divided in three parts: event loop : where you manage all the events which will happen in the game , update : where live the game logic, drawing : the part where you draw all the asset you want in the game. You could follow this way to correctly setup or organize your future game project. Free resources In this part you free (if necessary.. because it depends on your programming language) the all the memory you should have used in your game This just an overview of the organization of a video game project. It may change depend on the game engine and barely of the framework you use. So feel free to follow the way you want to follow Set up the game in CSFML Basics Let go to a new step. You wanna create a game. Let make first a simple window. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } int main() { sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; while (sfRenderWindow_isOpen(window)) { sfRenderWindow_clear(window, sfBlack); while (sfRenderWindow_pollEvent(window, &event)) { if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); } sfRenderWindow_display(window); } sfRenderWindow_destroy(window); } Put this code inside a file, file_name.c . You can compile this code with gcc file_name.c -lcsfml-graphics -lcsfml-window . If you launched it, you will see a black window. Simple and basic. Explanation Let explain this pretty code you've compiled. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> Those lines refer to the main include you will use for all your Epitech game project. It contains all you need for graphic, sound, manage user key input, etc.... sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } This function will be very useful through all the MUL projects you will build this year. It take in parameters the width, the height and the title of the screen. Inside, sfRenderWindow *Window refers to the window where all the game will be played, sfVideoMode mode refers to the screen's configuration (the width, the height and the number of bits per pixel which impact the global window's resolution). sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; I guess you can understand that... Don't be stupid :smirk:! while (sfRenderWindow_isOpen(window)) This is the main loop of the game, which run while window is not closed. It can be replace also by while(running) with running a boolean value set to true . Close the window is so the same as set running to false . sfRenderWindow_clear(window, sfBlack); This line allows screen to refresh every time all the actions you declare in the game loop ended. It make sure you will not have an error in your displaying. It also provide a way to set a custom background color. while (sfRenderWindow_pollEvent(window, &event)) It this loop, you will be able to handle every event which should happens at least one time such collision, user input and may other things. if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); This condition is just : \" If the event which happens is sfEvtClosed (if the user want to close the window by clicking on the red cross button on the top of your window), close the game's render window. \" sfRenderWindow_display(window); This line allows you to continue to display the game's window as the game is going on. sfRenderWindow_destroy(window); This line free the resources allocated to display the window. It is a VERY IMPORTANT STEP . It makes your program more stable and able to run with much amount of variables and data. How to use correctly the documentation There is no tutorials about CSFML on internet. The only one you will find is an portuguese video tutorial about it. But it still a few useless when you look at the amount of work you will have to achieve. The right way to use the documentation... That is a great deal to handle this year in graphical programming... 5 credits for the first semester and 9 for the second one. So I will give you some tips about it. The first thing you have to handle is the logic of the documentation. All the .h files located in the File tab. If you're looking for some functions about audio management, you have to search the Audio.h file documentation. And if you need something about sprite handling: Sprite.h , about keyboard management: Keyboard.h . By doing this you'll be able to easily find your way through this documentation. Other tips: Take time to read it . It is not difficult. And if you take time just to understand the way everything is going on through this docs, you'll easily be able to understand a lot about 2D game's logic. More tips and help If you want more tricks about CSFML... Don't hesitate to visit CleanSFML project.","title":"Csfml Library"},{"location":"tools_cheatsheet/csfml/#how-to-understand-and-start-2d-game","text":"","title":"How to understand and start 2D game \ud83d\udc7e"},{"location":"tools_cheatsheet/csfml/#understand-the-game","text":"A 2D game is mainly a kind of program which generally follow a guideline. It is made with 3 main parts: Initialization Game loop Free resources You notice the game core is the game loop. But we will describe the two others parts. Initialization In this part you load in memory all the component you want to use inside your game loop. You have to initialize the variables you want to use with the right element, sprite, sound, image, text, all your asset and whatever you want to use inside the game. It is also here you will fix the position of your assets (for example you will set the positions of all the assets, probably decide if you want to play the main sound of your game as soon as the game start). It is important to do this part before the game loop. Game loop The game loop is the main part of the game. It is here you will implement the game logic, manage events and also where you will draw the assets. By game logic, I mean all the game \"itself\". It is here you will define how the player will move, how the score will be displayed, what will happen if the player clicks on \"Play\" button, etc... It is here where you will define whatever should happen according to events. An event could be a keyboard input, collision between two objects, when a click happens and others such things. So the game loop is divided in three parts: event loop : where you manage all the events which will happen in the game , update : where live the game logic, drawing : the part where you draw all the asset you want in the game. You could follow this way to correctly setup or organize your future game project. Free resources In this part you free (if necessary.. because it depends on your programming language) the all the memory you should have used in your game This just an overview of the organization of a video game project. It may change depend on the game engine and barely of the framework you use. So feel free to follow the way you want to follow","title":"Understand the game"},{"location":"tools_cheatsheet/csfml/#set-up-the-game-in-csfml","text":"","title":"Set up the game in CSFML"},{"location":"tools_cheatsheet/csfml/#basics","text":"Let go to a new step. You wanna create a game. Let make first a simple window. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } int main() { sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; while (sfRenderWindow_isOpen(window)) { sfRenderWindow_clear(window, sfBlack); while (sfRenderWindow_pollEvent(window, &event)) { if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); } sfRenderWindow_display(window); } sfRenderWindow_destroy(window); } Put this code inside a file, file_name.c . You can compile this code with gcc file_name.c -lcsfml-graphics -lcsfml-window . If you launched it, you will see a black window. Simple and basic.","title":"Basics"},{"location":"tools_cheatsheet/csfml/#explanation","text":"Let explain this pretty code you've compiled. #include <SFML/Graphics.h> #include <SFML/Config.h> #include <SFML/Audio.h> #include <SFML/System.h> Those lines refer to the main include you will use for all your Epitech game project. It contains all you need for graphic, sound, manage user key input, etc.... sfRenderWindow *create_window(unsigned int width, unsigned int height, char const *title) { sfRenderWindow *Window; sfVideoMode mode; mode.width = width; mode.height = height; mode.bitsPerPixel = 32; Window = sfRenderWindow_create(mode, title, sfResize | sfClose, NULL); return (Window); } This function will be very useful through all the MUL projects you will build this year. It take in parameters the width, the height and the title of the screen. Inside, sfRenderWindow *Window refers to the window where all the game will be played, sfVideoMode mode refers to the screen's configuration (the width, the height and the number of bits per pixel which impact the global window's resolution). sfRenderWindow *window = create_window(800, 600, \"CSFML\"); sfEvent event; I guess you can understand that... Don't be stupid :smirk:! while (sfRenderWindow_isOpen(window)) This is the main loop of the game, which run while window is not closed. It can be replace also by while(running) with running a boolean value set to true . Close the window is so the same as set running to false . sfRenderWindow_clear(window, sfBlack); This line allows screen to refresh every time all the actions you declare in the game loop ended. It make sure you will not have an error in your displaying. It also provide a way to set a custom background color. while (sfRenderWindow_pollEvent(window, &event)) It this loop, you will be able to handle every event which should happens at least one time such collision, user input and may other things. if (event.type == sfEvtClosed || sfKeyboard_isKeyPressed(sfKeyEscape)) sfRenderWindow_close(window); This condition is just : \" If the event which happens is sfEvtClosed (if the user want to close the window by clicking on the red cross button on the top of your window), close the game's render window. \" sfRenderWindow_display(window); This line allows you to continue to display the game's window as the game is going on. sfRenderWindow_destroy(window); This line free the resources allocated to display the window. It is a VERY IMPORTANT STEP . It makes your program more stable and able to run with much amount of variables and data.","title":"Explanation"},{"location":"tools_cheatsheet/csfml/#how-to-use-correctly-the-documentation","text":"There is no tutorials about CSFML on internet. The only one you will find is an portuguese video tutorial about it. But it still a few useless when you look at the amount of work you will have to achieve. The right way to use the documentation... That is a great deal to handle this year in graphical programming... 5 credits for the first semester and 9 for the second one. So I will give you some tips about it. The first thing you have to handle is the logic of the documentation. All the .h files located in the File tab. If you're looking for some functions about audio management, you have to search the Audio.h file documentation. And if you need something about sprite handling: Sprite.h , about keyboard management: Keyboard.h . By doing this you'll be able to easily find your way through this documentation. Other tips: Take time to read it . It is not difficult. And if you take time just to understand the way everything is going on through this docs, you'll easily be able to understand a lot about 2D game's logic.","title":"How to use correctly the documentation"},{"location":"tools_cheatsheet/csfml/#more-tips-and-help","text":"If you want more tricks about CSFML... Don't hesitate to visit CleanSFML project.","title":"More tips and help"},{"location":"tools_cheatsheet/emacs/","text":"At Epitech, the default text editor is our good old emacs. However, Visual Studio Code is interfering in our relationship with emacs and is taking over from its many extensions and style. If you have used the kayofeld script , you are a winner . For the installation of emacs with Epitech configuration, you can use the script available in this github repository Epitech-emacs . Clone the repo with: $ git clone https://github.com/Epitech/epitech-emacs.git For local installation, run: $ ./INSTALL.sh local For system-wide installation, run: $ sudo ./INSTALL.sh system There is an emacs configuration allowing you to avoid some standard errors present in the coding style. Download the following file. Emacs Congifuration Put it in your home. Rename it to .emacs . Emacs Shortcuts: Ctrl C + Ctrl H : Project name and description Ctrl Z : Suspending emacs ( fg will resume the suspended job) Ctrl X + Ctrl S : Save Ctrl X + S : Save all files Ctrl X + Ctrl C : Quit Ctrl C + Ctrl Q : Auto Indent","title":"Emacs"},{"location":"tools_cheatsheet/gcc/","text":"Compile your project with: $ gcc file.c You can compile multiple file with: $ gcc file1.c file2.c This method with create a default name for your binary a.out If you want a specific name, you can use: $ gcc file.c -o your_binary_name Include a headers file directory $ gcc file.c -I ./include Include a library directory $ gcc file.c -L ./lib/my -l libmy You can use some flags to prevent warning in your code Wall Werror Wextra Type man gcc to find more info about it","title":"Gcc"},{"location":"tools_cheatsheet/git/","text":"Git is a distributed version-control system for tracking changes in source code during software development, created by Linus Torvalds in 2005 for development of the Linux kernel. It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed, data integrity, and support for distributed, non-linear workflows [clarification needed]. If you have used the kayofeld script , you are a winner . After creating your repo, you will have to clone it using: $ git clone surname.name@git.epitech.eu/surname.name@git.epitech.eu/repo_name If you are not the owner of the repo, replace the second surname.name by the owner login. Now you can create a file/folder and start working. You have to use these three commands every time you want to update your repe on the server. git add your_file // you can use `.` to add all the modified files git commit -m \"commit_message\" git push origin master If you are working with someone on the project, you can retrieve the changes from the server with: git pull There are a lot of git commands to manage your code. Especially when you are working on a project together. You can see a summary of the commands you can use on these sites. Git CheatSheet Git CheatSheet by GITHUB","title":"Git"},{"location":"tools_cheatsheet/makefile/","text":"A simple Makefile CC = gcc NAME = name_of_binary CFLAGS = -Wpedantic -pedantic-errors -w -Wextra -Wall -Iinclude SRC = core/my_printf.c \\ core/save_printf.c \\ src/my_putstr.c \\ src/my_putchar.c \\ src/my_strlen.c \\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) -c $(OBJ) ar rc $(NAME) $(OBJ) clean: rm -f $(OBJ) fclean: clean rm -f $(NAME) re: fclean all .PHONY: fclean clean re Graphical Makefile Template In this template I have a folder named src where is located all my .c file except the main.c which is root located. The $(shell find src/ -name ' .c') means to Makefile to find all the .c files which are located in the folder src* including all the sub directory inside it. CC = gcc CSFML += -lcsfml-graphics -lcsfml-window -lcsfml-audio -lcsfml-system CFLAGS += -Wpedantic -pedantic-errors -w -Wextra -Wall $(CSFML) -Iinc NAME = name_of_the_binary SRC = $(shell find src/ -name '*.c')\\ main.c OBJ = $(SRC:.c=.o) all: $(NAME) $(NAME): $(OBJ) $(CC) $(CFLAGS) $(OBJ) $(LIB) -o $(NAME) rm -f $(OBJ) *~ clean: rm -f src/*.o rm -f *~ core/*~ inc/*~ src/*~ fclean: clean rm -f $(NAME) rm -f a.out src/a.out core/a.out a.out re: fclean all .PHONY: fclean clean re Some useful flags and possibilities of customs makefile you can use","title":"Makefile"},{"location":"tools_cheatsheet/ncurses/","text":"All the basics tools of ncurses lib","title":"Ncurses Library"}]}